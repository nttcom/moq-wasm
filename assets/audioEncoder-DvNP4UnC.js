(function(){"use strict";function u(e,n=1e3){let o=0,s=performance.now();return{addBytes(a){o+=a;const d=performance.now();if(d-s>=n){const l=o*8/1e3;e(l),o=0,s=d}}}}let i,r=null,t={codec:"opus",sampleRate:48e3,numberOfChannels:1,bitrate:64e3};const c=u(e=>{self.postMessage({type:"bitrate",media:"audio",kbps:e})});function f(e,n){c.addBytes(e.byteLength),console.debug("sendAudioChunkMessage",e,n),r===null&&(r=e.timestamp,console.info("[audioEncoder] Set timestamp offset:",r));const o=e.timestamp-r,s=new ArrayBuffer(e.byteLength);e.copyTo(s);const a=new EncodedAudioChunk({type:e.type,timestamp:o,duration:e.duration??void 0,data:s});self.postMessage({type:"chunk",chunk:a,metadata:n})}async function p(){const e={output:f,error:o=>{console.log(o.message)}},n=new AudioEncoder(e);try{if(!(await AudioEncoder.isConfigSupported(t)).supported){self.postMessage({type:"configError",media:"audio",reason:"unsupported",config:t});return}}catch{self.postMessage({type:"configError",media:"audio",reason:"unsupported",config:t});return}return n.configure(t),console.info("[audioEncoder] initialized",t),n}async function g(e){if(r=null,i||(i=await p()),!i)return;const n=e.getReader();for(;;){const o=await n.read();if(o.done)break;const s=o.value;i.encode(s),s.close()}}self.onmessage=async e=>{if(e.data.type==="config"){const o=e.data.config;if(t={...t,...o},i&&i.state!=="closed")try{if(!(await AudioEncoder.isConfigSupported(t)).supported){self.postMessage({type:"configError",media:"audio",reason:"unsupported",config:t});return}i.configure(t),console.info("[audioEncoder] reconfigured",t)}catch{self.postMessage({type:"configError",media:"audio",reason:"unsupported",config:t});return}return}const n=e.data.audioStream;if(!n){console.error("MediaStreamTrack が渡されていません");return}await g(n)}})();
