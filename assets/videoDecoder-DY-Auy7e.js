(function(){"use strict";function p(o){if(o.byteLength<4)throw new Error("Payload too small to contain metadata");const t=new DataView(o.buffer,o.byteOffset,o.byteLength).getUint32(0),n=4+t;if(o.byteLength<n)throw new Error("Payload too small to contain metadata");const s=o.slice(4,4+t),r=JSON.parse(new TextDecoder().decode(s)),d=o.slice(4+t);return{metadata:r,data:d}}const l=50,h=1800,b=3;class I{constructor(e=h,t="normal",n){this.maxBufferSize=e,this.mode=t,this.keyframeInterval=typeof n=="number"?BigInt(n):n??void 0}buffer=[];minDelayMs=l;lastPoppedGroupId=null;lastPoppedObjectId=null;keyframeInterval;setMinDelay(e){!Number.isFinite(e)||e<0||(this.minDelayMs=e)}push(e,t,n){if(!n.objectPayloadLength)return;const s=p(n.objectPayload);if(!s)return;const r=n;if(r.cachedChunk=s,r.remotePTS=s.metadata.timestamp,r.localPTS=performance.timeOrigin+performance.now(),this.mode==="correctly"&&this.shouldRejectOldData(e,t)){console.warn(`[VideoJitterBuffer] Rejecting old data. Expected: (group:${this.lastPoppedGroupId}, object:${this.lastPoppedObjectId}), Got: (group:${e}, object:${t})`);return}const d={groupId:e,objectId:t,bufferInsertTimestamp:performance.now(),sentAt:s.metadata.sentAt,object:r,isEndOfGroup:n.objectStatus===b},L=this.findInsertPos(e,t);this.buffer.splice(L,0,d),this.buffer.length>this.maxBufferSize&&(console.warn("[VideoJitterBuffer] Buffer full, dropping oldest entry"),this.buffer.shift())}pop(){return this.popWithMetadata()}popWithMetadata(){return this.buffer.length===0?null:this.mode==="normal"?this.popNormalMode():this.popCorrectlyMode()}popNormalMode(){const e=this.buffer[0];return performance.now()-e.bufferInsertTimestamp<this.minDelayMs?null:(this.buffer.shift(),this.recordPopResult(e),e)}popCorrectlyMode(){const e=this.getExpectedNextEntry();let t=this.buffer.findIndex(r=>r.groupId===e.groupId&&r.objectId===e.objectId);if(t===-1&&(t=this.findResyncIndex(),t===-1)){if(this.lastPoppedGroupId===null&&this.buffer.length>0){const r=this.buffer.slice(0,5).map(d=>`(g:${d.groupId}, o:${d.objectId})`);console.warn(`[VideoJitterBuffer] Expected first entry not found. Expected: (g:${e.groupId}, o:${e.objectId}), Buffer: [${r.join(", ")}]`)}return null}const n=this.buffer[t];return performance.now()-n.bufferInsertTimestamp<this.minDelayMs?null:(this.buffer.splice(t,1),this.recordPopResult(n),n)}shouldRejectOldData(e,t){return this.lastPoppedGroupId===null||this.lastPoppedObjectId===null?!1:e<this.lastPoppedGroupId||e===this.lastPoppedGroupId&&t<=this.lastPoppedObjectId}recordPopResult(e){this.lastPoppedGroupId=e.groupId,this.lastPoppedObjectId=e.objectId,e.isEndOfGroup&&(this.lastPoppedGroupId=e.groupId+1n,this.lastPoppedObjectId=-1n)}getExpectedNextEntry(){return this.lastPoppedGroupId===null||this.lastPoppedObjectId===null?{groupId:0n,objectId:0n}:this.keyframeInterval!==void 0&&this.lastPoppedObjectId===this.keyframeInterval-1n?{groupId:this.lastPoppedGroupId+1n,objectId:0n}:{groupId:this.lastPoppedGroupId,objectId:this.lastPoppedObjectId+1n}}findInsertPos(e,t){for(let n=this.buffer.length-1;n>=0;n--){const s=this.buffer[n];if(s.groupId===e&&s.objectId<t||s.groupId<e)return n+1}return 0}findResyncIndex(){return this.buffer.length===0?-1:this.lastPoppedGroupId===null?0:this.buffer.findIndex(e=>e.objectId===0n&&e.groupId>this.lastPoppedGroupId)}}const m=300;function g(o,e=1e3){let t=0,n=performance.now();return{addBytes(s){t+=s;const r=performance.now();if(r-n>=e){const d=t*8/1e3;o(d),t=0,n=r}}}}const E=g(o=>{self.postMessage({type:"bitrate",kbps:o})}),u=BigInt(m),y={codec:"avc1.640028",avc:{format:"annexb"},hardwareAcceleration:"prefer-hardware",width:1920,height:1080,scalabilityMode:"L1T1"};let a;async function j(){function o(n){self.postMessage({type:"frame",frame:n}),n.close()}const e={output:o,error:n=>{console.log(n.message),a=void 0}},t=new VideoDecoder(e);return t.configure(y),t}const P=5,f=new I(1800,"correctly",u);let i=null,c=!1;function T(o,e){if(!i){(o!==0n||e!==0n)&&console.warn(`[Video] First frame must be groupId=0, objectId=0 (keyframe). Got: groupId=${o}, objectId=${e}`);return}if(o!==i.groupId){if(!c){const t=u-1n;i.objectId!==t&&console.debug(`[Video] Group ended with unexpected objectId. Expected: ${t}, Got: ${i.objectId}, Group: ${i.groupId} -> ${o}`)}e!==0n&&console.warn(`[Video] New group should start with objectId 0. Got: ${e}, GroupId: ${o}`);return}e!==i.objectId+1n&&console.warn(`[Video] Non-sequential objectId detected. Expected: ${i.objectId+1n}, Got: ${e}, Gap: ${e-i.objectId-1n}`)}function w(o,e){c=!1,i={groupId:o,objectId:e}}function G(){c=!0}setInterval(()=>{const o=f.popWithMetadata();if(o){if(o.isEndOfGroup){G();return}M(o.groupId,o.object)}},P),self.onmessage=async o=>{const e={objectId:o.data.subgroupStreamObject.objectId,objectPayloadLength:o.data.subgroupStreamObject.objectPayloadLength,objectPayload:new Uint8Array(o.data.subgroupStreamObject.objectPayload),objectStatus:o.data.subgroupStreamObject.objectStatus};E.addBytes(e.objectPayloadLength),f.push(o.data.groupId,e.objectId,e)};async function M(o,e){T(o,e.objectId),w(o,e.objectId);const t=e.cachedChunk;_(t.metadata.sentAt,"video");const n=new EncodedVideoChunk({type:t.metadata.type,timestamp:t.metadata.timestamp,duration:t.metadata.duration??void 0,data:t.data});(!a||a.state==="closed")&&(a=await j(),t.metadata.type!=="key")||await a.decode(n)}function _(o,e){if(typeof o!="number")return;const t=Date.now()-o;!Number.isFinite(t)||t<0||self.postMessage({type:"latency",media:e,ms:t})}})();
