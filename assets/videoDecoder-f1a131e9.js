var x=Object.defineProperty;var A=(u,i,c)=>i in u?x(u,i,{enumerable:!0,configurable:!0,writable:!0,value:c}):u[i]=c;var f=(u,i,c)=>(A(u,typeof i!="symbol"?i+"":i,c),c);(function(){"use strict";function i(t){if(t.byteLength<4)return null;const o=new DataView(t.buffer,t.byteOffset,t.byteLength).getUint32(0),n=4+o;if(t.byteLength<n)return null;const r=t.slice(4,4+o),s=JSON.parse(new TextDecoder().decode(r)),a=t.slice(4+o);return{metadata:s,data:a}}const c=50,I=1800,m=500,g=3;class E{constructor(e=I,o,n){f(this,"buffer",[]);f(this,"minDelayMs",c);f(this,"lastPoppedGroupId",null);f(this,"lastPoppedObjectId",null);f(this,"keyframeInterval");this.maxBufferSize=e,this.mode=o,this.keyframeInterval=typeof n=="number"?BigInt(n):n??void 0}setMinDelay(e){!Number.isFinite(e)||e<0||(this.minDelayMs=e)}push(e,o,n){if(!n.objectPayloadLength)return;const r=i(n.objectPayload);if(!r)return;const s=n;if(s.cachedChunk=r,this.mode==="video_correctly"&&this.shouldRejectOldData(e,o)){console.warn(`[JitterBuffer] Rejecting old data. Expected: (group:${this.lastPoppedGroupId}, object:${this.lastPoppedObjectId}), Got: (group:${e}, object:${o})`);return}const a=performance.now(),D={groupId:e,objectId:o,timestamp:a,object:s,isEndOfGroup:n.objectStatus===g,referenceTime:j(r.metadata)},N=this.findInsertPos(e,o);this.buffer.splice(N,0,D),this.mode==="audio"&&this.dropStaleEntries(m),this.buffer.length>this.maxBufferSize&&(console.warn("JitterBuffer is full, removing the oldest element"),this.buffer.shift())}shouldRejectOldData(e,o){return this.lastPoppedGroupId===null||this.lastPoppedObjectId===null?!1:e<this.lastPoppedGroupId||e===this.lastPoppedGroupId&&o<=this.lastPoppedObjectId}pop(){const e=this.popWithMetadata();return e?e.object:null}popWithMetadata(){return this.buffer.length===0?null:this.mode==="video_normal"||this.mode==="audio"?this.popNormalMode():this.popCorrectlyMode()}popNormalMode(){const e=this.buffer[0];return performance.now()-e.timestamp<this.minDelayMs?null:(this.buffer.shift(),this.recordPopResult(e),e)}popCorrectlyMode(){const e=this.getExpectedNextEntry();let o=this.buffer.findIndex(s=>s.groupId===e.groupId&&s.objectId===e.objectId);if(o===-1&&(o=this.findResyncIndex(),o===-1)){if(this.lastPoppedGroupId===null&&this.buffer.length>0){const s=this.buffer.slice(0,5).map(a=>`(g:${a.groupId}, o:${a.objectId})`);console.warn(`[JitterBuffer] Expected first entry not found. Expected: (g:${e.groupId}, o:${e.objectId}), Buffer: [${s.join(", ")}]`)}return null}const n=this.buffer[o];return performance.now()-n.timestamp<this.minDelayMs?null:(this.buffer.splice(o,1),this.recordPopResult(n),n)}recordPopResult(e){this.lastPoppedGroupId=e.groupId,this.lastPoppedObjectId=e.objectId,e.isEndOfGroup&&(this.lastPoppedGroupId=e.groupId+1n,this.lastPoppedObjectId=-1n)}getExpectedNextEntry(){return this.lastPoppedGroupId===null||this.lastPoppedObjectId===null?{groupId:0n,objectId:0n}:this.keyframeInterval!==void 0&&this.lastPoppedObjectId===this.keyframeInterval-1n?{groupId:this.lastPoppedGroupId+1n,objectId:0n}:{groupId:this.lastPoppedGroupId,objectId:this.lastPoppedObjectId+1n}}findInsertPos(e,o){for(let n=this.buffer.length-1;n>=0;n--){const r=this.buffer[n];if(r.groupId===e&&r.objectId<o||r.groupId<e)return n+1}return 0}findResyncIndex(){return this.buffer.length===0?-1:this.lastPoppedGroupId===null?0:this.buffer.findIndex(e=>e.objectId===0n&&e.groupId>this.lastPoppedGroupId)}dropStaleEntries(e){const o=Date.now();for(;this.buffer.length>0;){const r=this.buffer[0].referenceTime;if(r===void 0||o-r<=e)break;this.buffer.shift()}}}function j(t){if(typeof t.sentAt=="number")return t.sentAt;if(typeof t.timestamp=="number")return performance.timeOrigin+t.timestamp/1e3}const y=300;function T(t,e=1e3){let o=0,n=performance.now();return{addBytes(r){o+=r;const s=performance.now();if(s-n>=e){const a=o*8/1e3;t(a),o=0,n=s}}}}const P=T(t=>{self.postMessage({type:"bitrate",kbps:t})}),h=BigInt(y),_={codec:"avc1.640028",avc:{format:"annexb"},hardwareAcceleration:"prefer-hardware",width:1920,height:1080,scalabilityMode:"L1T1"};let p;async function w(){function t(n){self.postMessage({type:"frame",frame:n}),n.close()}const e={output:t,error:n=>{console.log(n.message),p=void 0}},o=new VideoDecoder(e);return o.configure(_),o}const G=5,b=new E(1800,"video_correctly",h);let d=null,l=!1;function M(t,e){if(!d){(t!==0n||e!==0n)&&console.warn(`[Video] First frame must be groupId=0, objectId=0 (keyframe). Got: groupId=${t}, objectId=${e}`);return}if(t!==d.groupId){if(!l){const o=h-1n;d.objectId!==o&&console.debug(`[Video] Group ended with unexpected objectId. Expected: ${o}, Got: ${d.objectId}, Group: ${d.groupId} -> ${t}`)}e!==0n&&console.warn(`[Video] New group should start with objectId 0. Got: ${e}, GroupId: ${t}`);return}e!==d.objectId+1n&&console.warn(`[Video] Non-sequential objectId detected. Expected: ${d.objectId+1n}, Got: ${e}, Gap: ${e-d.objectId-1n}`)}function L(t,e){l=!1,d={groupId:t,objectId:e}}function O(){l=!0}setInterval(()=>{const t=b.popWithMetadata();if(t){if(t.isEndOfGroup){O();return}S(t.groupId,t.object)}},G),self.onmessage=async t=>{const e={objectId:t.data.subgroupStreamObject.objectId,objectPayloadLength:t.data.subgroupStreamObject.objectPayloadLength,objectPayload:new Uint8Array(t.data.subgroupStreamObject.objectPayload),objectStatus:t.data.subgroupStreamObject.objectStatus};P.addBytes(e.objectPayloadLength),b.push(t.data.groupId,e.objectId,e)};async function S(t,e){M(t,e.objectId),L(t,e.objectId);const o=e.cachedChunk;B(o.metadata.sentAt,"video");const n=new EncodedVideoChunk({type:o.metadata.type,timestamp:o.metadata.timestamp,duration:o.metadata.duration??void 0,data:o.data});(!p||p.state==="closed")&&(p=await w(),o.metadata.type!=="key")||await p.decode(n)}function B(t,e){if(typeof t!="number")return;const o=Date.now()-t;!Number.isFinite(o)||o<0||self.postMessage({type:"latency",media:e,ms:o})}})();
