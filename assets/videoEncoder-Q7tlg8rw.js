(function(){"use strict";function l(e,o=1e3){let a=0,n=performance.now();return{addBytes(i){a+=i;const r=performance.now();if(r-n>=o){const m=a*8/1e3;e(m),a=0,n=r}}}}let t,c;const d={codec:"avc1.640028",avc:{format:"annexb"},width:1920,height:1080,bitrate:1e6,scalabilityMode:"L1T1",framerate:30,latencyMode:"realtime"},u=l(e=>{self.postMessage({type:"bitrate",kbps:e})});function f(e,o){u.addBytes(e.byteLength),self.postMessage({type:"chunk",chunk:e,metadata:o})}async function s(){const e={output:f,error:a=>{console.log(a.message)}};console.log("isEncoderConfig Supported",await VideoEncoder.isConfigSupported(d));const o=new VideoEncoder(e);return o.configure(d),o}async function g(e){let o=0;console.log("initializeVideoEncoder"),t=await s();const a=e.getReader();for(;;){const n=await a.read();if(n.done)break;const i=n.value;if(t.encodeQueueSize>10){console.error("videoEncoder.encodeQueueSize > 10",t.encodeQueueSize),i.close();continue}(!t||t.state==="closed")&&(console.log("Re-initialize video encoder"),t=await s(),o=0);const r=o%c==0;t.encode(i,{keyFrame:r}),o++,i.close()}}self.onmessage=async e=>{if(console.debug("videoEncoder worker received message",e.data),e.data.type==="keyframeInterval")c=e.data.keyframeInterval;else if(e.data.type==="videoStream"){const o=e.data.videoStream;if(!o){console.error("MediaStreamTrack が渡されていません");return}await g(o)}}})();
