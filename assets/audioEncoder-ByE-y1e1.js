(function(){"use strict";function a(e,t=1e3){let n=0,s=performance.now();return{addBytes(p){n+=p;const i=performance.now();if(i-s>=t){const g=n*8/1e3;e(g),n=0,s=i}}}}let r,o={codec:"opus",sampleRate:48e3,numberOfChannels:1,bitrate:64e3};const d=a(e=>{self.postMessage({type:"bitrate",media:"audio",kbps:e})});function u(e,t){d.addBytes(e.byteLength),console.debug("sendAudioChunkMessage",e,t),self.postMessage({type:"chunk",chunk:e,metadata:t})}async function c(){const e={output:u,error:n=>{console.log(n.message)}},t=new AudioEncoder(e);try{if(!(await AudioEncoder.isConfigSupported(o)).supported){self.postMessage({type:"configError",media:"audio",reason:"unsupported",config:o});return}}catch{self.postMessage({type:"configError",media:"audio",reason:"unsupported",config:o});return}return t.configure(o),console.info("[audioEncoder] initialized",o),t}async function f(e){if(r||(r=await c()),!r)return;const t=e.getReader();for(;;){const n=await t.read();if(n.done)break;const s=n.value;r.encode(s),s.close()}}self.onmessage=async e=>{if(e.data.type==="config"){const n=e.data.config;if(o={...o,...n},r&&r.state!=="closed")try{if(!(await AudioEncoder.isConfigSupported(o)).supported){self.postMessage({type:"configError",media:"audio",reason:"unsupported",config:o});return}r.configure(o),console.info("[audioEncoder] reconfigured",o)}catch{self.postMessage({type:"configError",media:"audio",reason:"unsupported",config:o});return}return}const t=e.data.audioStream;if(!t){console.error("MediaStreamTrack が渡されていません");return}await f(t)}})();
